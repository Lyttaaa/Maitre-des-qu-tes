import os
import re
import json
import unicodedata
from random import choice

import discord
from discord.ext import commands
from discord.ui import View
from pymongo import MongoClient

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
import pytz

# --- Loader quetes + index par ID ------------------------------------------
import json
import os

# Chemin vers ton JSON (adapte si besoin)
CHEMIN_QUETES = os.getenv("QUETES_JSON_PATH", "quetes.json")

# Cache global
QUETES_RAW = None
QUETES_INDEX = {}   # {"QE012": {"id": "...", ...}, ...}
CATEGORIE_PAR_ID = {}  # {"QE012": "Qu√™tes √ânigmes", ...}

def charger_toutes_les_quetes():
    global QUETES_RAW, QUETES_INDEX, CATEGORIE_PAR_ID
    if QUETES_RAW is not None:
        return  # d√©j√† charg√©

    with open(CHEMIN_QUETES, "r", encoding="utf-8") as f:
        QUETES_RAW = json.load(f)

    QUETES_INDEX.clear()
    CATEGORIE_PAR_ID.clear()

    # Liste des cat√©gories possibles selon ta structure
    categories_possibles = [
        "Qu√™tes Interactions",
        "Qu√™tes Recherches",
        "Qu√™tes √ânigmes",
        # si tu as aussi les "(AJOUTS)" dans un autre fichier/canvas, ajoute-les ici :
        "Qu√™tes Interactions (AJOUTS)",
        "Qu√™tes Recherches (AJOUTS)",
        "Qu√™tes √ânigmes (AJOUTS)",
    ]

    for cat in categories_possibles:
        if cat not in QUETES_RAW:
            continue
        for q in QUETES_RAW[cat]:
            qid = q.get("id", "").upper()
            if not qid:
                continue
            QUETES_INDEX[qid] = q
            # si tes ajouts portent la m√™me nature, on ‚Äúnormalize‚Äù la cat√©gorie
            if "Interaction" in cat:
                CATEGORIE_PAR_ID[qid] = "Qu√™tes Interactions"
            elif "Recherche" in cat:
                CATEGORIE_PAR_ID[qid] = "Qu√™tes Recherches"
            elif "√ânigme" in cat or "Enigme" in cat:
                CATEGORIE_PAR_ID[qid] = "Qu√™tes √ânigmes"
            else:
                CATEGORIE_PAR_ID[qid] = cat

def charger_quete_par_id(quest_id: str):
    """Retourne l'objet qu√™te (dict) pour un ID donn√©, sinon None."""
    charger_toutes_les_quetes()
    return QUETES_INDEX.get(quest_id.upper())

def categorie_par_id(quest_id: str) -> str:
    charger_toutes_les_quetes()
    return CATEGORIE_PAR_ID.get(quest_id.upper(), "Qu√™te")

# ======================
#  CONFIG DISCORD & DB
# ======================
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.reactions = True

bot = commands.Bot(command_prefix="!", intents=intents)

MONGO_URI = os.getenv("MONGO_URI")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
QUESTS_CHANNEL_ID = int(os.getenv("QUESTS_CHANNEL_ID", "0"))
ANNOUNCE_CHANNEL_ID = int(os.getenv("ANNOUNCE_CHANNEL_ID", "0"))  # optionnel

# --- MongoDB (safe with PyMongo) ---
import os
try:
    from pymongo import MongoClient
except ImportError:
    MongoClient = None

MONGO_URI = os.getenv("MONGO_URI")

if MongoClient is None or not MONGO_URI:
    raise RuntimeError("MONGO_URI (et pymongo) sont requis pour le Ma√Ætre des Qu√™tes.")

mongo_client = MongoClient(MONGO_URI)
db = mongo_client.get_database("lumharel_bot")  # nom utilis√© c√¥t√© PNJ aussi

# ‚ö†Ô∏è Ne JAMAIS faire `if db:` avec PyMongo ; utiliser `is not None`
accepted_collection   = db.quetes_acceptees
completed_collection  = db.quetes_terminees
utilisateurs          = db.utilisateurs
rotation_collection   = db.rotation_quetes
user_state            = db.user_state  # <-- n√©cessaire pour stocker active_interaction

TZ_PARIS = pytz.timezone("Europe/Paris")

# ======================
#  CONSTANTES UI
# ======================
EMOJI_PAR_CATEGORIE = {
    "Qu√™tes Journali√®res": "üïò",
    "Qu√™tes Interactions": "üïπÔ∏è",
    "Qu√™tes Recherches": "üîç",
    "Qu√™tes √ânigmes": "üß©",
}
COULEURS_PAR_CATEGORIE = {
    "Qu√™tes Journali√®res": 0x4CAF50,
    "Qu√™tes Interactions": 0x2196F3,
    "Qu√™tes Recherches": 0x9C27B0,
    "Qu√™tes √ânigmes": 0xFFC107,
}

# ======================
#  UTILS
# ======================
def ids_quetes(liste):
    return [q["id"] if isinstance(q, dict) else q for q in liste]

def normaliser(texte):
    if not isinstance(texte, str):
        return ""
    texte = texte.lower().strip()
    texte = unicodedata.normalize("NFKD", texte)
    texte = "".join(c for c in texte if not unicodedata.combining(c))
    texte = texte.replace("‚Äô", "'")
    texte = re.sub(r'[‚Äú‚Äù¬´¬ª]', '"', texte)
    texte = re.sub(r"\s+", " ", texte)
    texte = texte.replace("\u200b", "")
    return texte

def charger_quetes():
    with open(CHEMIN_QUETES, "r", encoding="utf-8") as f:
        data = json.load(f)
    for categorie, quetes in data.items():
        for quete in quetes:
            quete["categorie"] = categorie
    return data


async def purger_messages_categorie(channel: discord.TextChannel, categorie: str, limit=100):
    """
    Supprime uniquement les anciens messages du bot qui contiennent un embed
    dont le titre commence par l‚Äôemoji de la cat√©gorie.
    """
    prefix = EMOJI_PAR_CATEGORIE.get(categorie, "")
    async for message in channel.history(limit=limit):
        if message.author == bot.user and message.embeds:
            title = message.embeds[0].title or ""
            if title.startswith(prefix):
                try:
                    await message.delete()
                except:
                    pass

async def envoyer_quete(channel, quete, categorie):
    emoji = EMOJI_PAR_CATEGORIE.get(categorie, "‚ùì")
    couleur = COULEURS_PAR_CATEGORIE.get(categorie, 0xCCCCCC)
    titre = f"{emoji} {categorie}\n‚Äì {quete['id']} {quete['nom']}"

    embed = discord.Embed(title=titre, description=quete["resume"], color=couleur)
    type_texte = f"{categorie} ‚Äì {quete['recompense']} Lumes"
    embed.add_field(name="üìå Type & R√©compense", value=type_texte, inline=False)
    embed.set_footer(text="Clique sur le bouton ci-dessous pour accepter la qu√™te.")
    await channel.send(embed=embed, view=VueAcceptation(quete, categorie))

def get_quete_non_postee(categorie, quetes_possibles):
    doc = rotation_collection.find_one({"_id": categorie})
    deja_postees = doc["postees"] if doc else []
    restantes = [q for q in quetes_possibles if q["id"] not in deja_postees]
    if not restantes:
        restantes = quetes_possibles
        deja_postees = []
    quete = choice(restantes)
    rotation_collection.update_one(
        {"_id": categorie},
        {"$set": {"postees": deja_postees + [quete["id"]]}},
        upsert=True
    )
    return quete

# ======================
#  VUE BOUTON "ACCEPTER"
# ======================
class VueAcceptation(View):
    def __init__(self, quete, categorie):
        super().__init__(timeout=None)
        self.quete = quete
        self.categorie = categorie

    @discord.ui.button(label="Accepter üì•", style=discord.ButtonStyle.green)
    async def accepter(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = str(interaction.user.id)
        quete_id = self.quete["id"]

        # d√©j√† accept√©e ?
        quete_data = accepted_collection.find_one({"_id": user_id})
        if quete_data and any(q.get("id") == quete_id for q in quete_data.get("quetes", [])):
            await interaction.response.send_message(
                "Tu as d√©j√† accept√© cette qu√™te ! Consulte `!mes_quetes`.",
                ephemeral=True
            )
            return

        # d√©j√† termin√©e ? (sauf journali√®res)
        deja_faite = completed_collection.find_one(
            {"_id": user_id, "quetes": {"$elemMatch": {"id": quete_id}}}
        )
        if deja_faite and self.categorie != "Qu√™tes Journali√®res":
            try:
                await interaction.user.send(
                    f"üì™ Tu as d√©j√† termin√© **{self.quete['nom']}** (non rejouable). "
                    "Consulte `!mes_quetes`."
                )
            except discord.Forbidden:
                await interaction.response.send_message(
                    "Tu as d√©j√† termin√© cette qu√™te (non rejouable), et je ne peux pas t‚Äôenvoyer de MP.",
                    ephemeral=True
                )
            return

        accepted_collection.update_one(
            {"_id": user_id},
            {"$addToSet": {
                "quetes": {
                    "categorie": self.categorie,
                    "id": quete_id,
                    "nom": self.quete["nom"]
                }
            }, "$set": {"pseudo": interaction.user.name}},
            upsert=True
        )

        # ‚ûï ICI : on ajoute la cr√©ation d‚Äôun √©tat actif pour les qu√™tes d‚Äôinteraction
        if self.categorie == "Qu√™tes Interactions":
            etat = {
                "quest_id": self.quete["id"],
                "type": self.quete.get("type", "interaction"),  # "multi_step" ou "interaction"
                "pnj": (self.quete.get("pnj") or "").strip(),
                # progression multi-√©tapes
                "current_step": 1 if self.quete.get("type") == "multi_step" else None,
                "awaiting_reaction": False,
                "emoji": None
            }
            user_state.update_one(
                {"_id": str(interaction.user.id)},
                {"$set": {"active_interaction": etat}},
                 upsert=True
            )
            
        # MP d‚Äôinstructions
        if self.categorie == "Qu√™tes √ânigmes":
            embed = discord.Embed(
                title="üß© Qu√™te √ânigmes",
                description=f"**{self.quete['id']} ‚Äì {self.quete['nom']}**",
                color=COULEURS_PAR_CATEGORIE.get(self.categorie, 0xCCCCCC)
            )

            img = self.quete.get("image_url")

            if img:
                # Si un r√©bus visuel existe, on ne montre pas l‚Äô√©nonc√© texte
                embed.add_field(name="üí¨ R√©bus", value="Observe bien ce symbole...", inline=False)
                embed.set_image(url=img)
            else:
                # Sinon on affiche le texte d‚Äô√©nigme classique
                embed.add_field(name="üí¨ √ânonc√©", value=self.quete["enonce"], inline=False)

            embed.add_field(name="üëâ Objectif", value="Trouve la r√©ponse et r√©ponds-moi ici.", inline=False)
            embed.set_footer(text=f"üèÖ R√©compense : {self.quete['recompense']} Lumes")
        else:
            titre_embed = f"{EMOJI_PAR_CATEGORIE.get(self.categorie, 'üìú')} {self.categorie}"
            embed = discord.Embed(
                title=titre_embed,
                description=f"**{self.quete['id']} ‚Äì {self.quete['nom']}**",
                color=COULEURS_PAR_CATEGORIE.get(self.categorie, 0xCCCCCC)
            )
            embed.add_field(name="üí¨ Description", value=self.quete["description"], inline=False)
            embed.add_field(name="üëâ Objectif", value=self.quete["details_mp"], inline=False)
            embed.set_footer(text=f"üèÖ R√©compense : {self.quete['recompense']} Lumes")

        try:
            await interaction.user.send(embed=embed)
            await interaction.response.send_message(
                "Qu√™te accept√©e ‚úÖ Regarde tes MP ! (`!mes_quetes` pour le suivi)",
                ephemeral=True
            )
        except discord.Forbidden:
            await interaction.response.send_message("Je n'arrive pas √† t'envoyer de MP üòÖ", ephemeral=True)

# ======================
#  POSTERS
# ======================
async def poster_journalieres():
    """Poste seulement les 2 qu√™tes journali√®res (tous les jours)."""
    quetes_par_type = charger_quetes()
    channel = bot.get_channel(QUESTS_CHANNEL_ID)
    if not channel:
        print("‚ùå Channel qu√™tes introuvable.")
        return

    await purger_messages_categorie(channel, "Qu√™tes Journali√®res", limit=100)
    for quete in quetes_par_type.get("Qu√™tes Journali√®res", [])[:2]:
        await envoyer_quete(channel, quete, "Qu√™tes Journali√®res")
    print("‚úÖ Journali√®res post√©es.")

async def poster_hebdo():
    """Poste 1 interaction + 1 recherche + 1 √©nigme avec rotation (chaque semaine)."""
    quetes_par_type = charger_quetes()
    channel = bot.get_channel(QUESTS_CHANNEL_ID)
    if not channel:
        print("‚ùå Channel qu√™tes introuvable.")
        return

    # Interactions
    interactions = quetes_par_type.get("Qu√™tes Interactions", [])
    if interactions:
        await purger_messages_categorie(channel, "Qu√™tes Interactions", limit=100)
        q = get_quete_non_postee("Qu√™tes Interactions", interactions)
        await envoyer_quete(channel, q, "Qu√™tes Interactions")

    # Recherches
    recherches = quetes_par_type.get("Qu√™tes Recherches", [])
    if recherches:
        await purger_messages_categorie(channel, "Qu√™tes Recherches", limit=100)
        q = get_quete_non_postee("Qu√™tes Recherches", recherches)
        await envoyer_quete(channel, q, "Qu√™tes Recherches")

    # √ânigmes
    enigmes = quetes_par_type.get("Qu√™tes √ânigmes", [])
    if enigmes:
        await purger_messages_categorie(channel, "Qu√™tes √ânigmes", limit=100)
        q = get_quete_non_postee("Qu√™tes √ânigmes", enigmes)
        await envoyer_quete(channel, q, "Qu√™tes √ânigmes")

    print("‚úÖ Hebdomadaires post√©es.")

async def annoncer_mise_a_jour():
    if not ANNOUNCE_CHANNEL_ID:
        return
    ch = bot.get_channel(ANNOUNCE_CHANNEL_ID)
    if ch:
        await ch.send(
            "üëã Oyez oyez, <@&1345479226886979641> ! Les qu√™tes **journali√®res** et/ou **hebdomadaires** ont √©t√© mises √† jour "
            f"dans <#{QUESTS_CHANNEL_ID}>. Puissent les Souffles vous √™tre favorables üå¨Ô∏è !"
        )

# ======================
#  COMMANDES
# ======================
@bot.command()
@commands.has_permissions(administrator=True)
async def poster_quetes(ctx):
    """Poste tout d‚Äôun coup (journali√®res + hebdo) ‚Äî commande admin."""
    await poster_journalieres()
    await poster_hebdo()
    await annoncer_mise_a_jour()
    await ctx.reply("‚úÖ Qu√™tes post√©es (journali√®res + hebdo).")

@bot.command()
@commands.has_permissions(administrator=True)
async def journaliere(ctx):
    await poster_journalieres()
    await ctx.reply("‚úÖ Journali√®res post√©es.")

@bot.command()
@commands.has_permissions(administrator=True)
async def hebdo(ctx):
    await poster_hebdo()
    await ctx.reply("‚úÖ Hebdomadaires post√©es.")

@bot.command()
async def mes_quetes(ctx):
    user_id = str(ctx.author.id)
    toutes_quetes = [q for lst in charger_quetes().values() for q in lst]

    user_accept = accepted_collection.find_one({"_id": user_id}) or {}
    user_done = completed_collection.find_one({"_id": user_id}) or {}

    quetes_accept = user_accept.get("quetes", [])
    quetes_done = user_done.get("quetes", [])

    ids_accept = set(q["id"] if isinstance(q, dict) else q for q in quetes_accept)
    ids_done = set(q.get("id") if isinstance(q, dict) else q for q in quetes_done)

    categories = {
        "Qu√™tes Journali√®res": {"emoji": "üïò", "encours": [], "terminees": []},
        "Qu√™tes Interactions": {"emoji": "üïπÔ∏è", "encours": [], "terminees": []},
        "Qu√™tes Recherches": {"emoji": "üîç", "encours": [], "terminees": []},
        "Qu√™tes √ânigmes": {"emoji": "üß©", "encours": [], "terminees": []},
    }

    for quete in toutes_quetes:
        cat = quete.get("categorie")
        if not cat or cat not in categories:
            continue
        ligne = f"‚Ä¢ {quete['id']} ‚Äì {quete['nom']}"
        if quete["id"] in ids_done:
            categories[cat]["terminees"].append(ligne)
        elif quete["id"] in ids_accept:
            categories[cat]["encours"].append(ligne)

    embed = discord.Embed(
        title=f"üìò Qu√™tes de {ctx.author.display_name}",
        color=0xA86E2A
    )
    desc = "üìú **Qu√™tes en cours**\n"
    for cat, data in categories.items():
        desc += f"{data['emoji']} __{cat.replace('Qu√™tes ', '')} :__\n"
        desc += "\n".join(data["encours"]) + "\n" if data["encours"] else "*Aucune*\n"

    desc += "\nüèÖ **Qu√™tes termin√©es**\n"
    for cat, data in categories.items():
        desc += f"{data['emoji']} __{cat.replace('Qu√™tes ', '')} :__\n"
        desc += "\n".join(data["terminees"]) + "\n" if data["terminees"] else "*Aucune*\n"

    embed.description = desc
    await ctx.send(embed=embed)

@bot.command()
async def bourse(ctx):
    user_id = str(ctx.author.id)
    user = utilisateurs.find_one({"_id": user_id})
    if not user:
        utilisateurs.insert_one({
            "_id": user_id,
            "pseudo": ctx.author.name,
            "lumes": 0,
            "derniere_offrande": {},
            "roles_temporaires": {},
        })
        user = utilisateurs.find_one({"_id": user_id}) or {}
    await ctx.send(f"üí∞ {ctx.author.mention}, tu poss√®des **{user.get('lumes', 0)} Lumes**.")

import discord
from discord.ext import commands

NO_MENTIONS = discord.AllowedMentions(everyone=False, users=True, roles=False, replied_user=False)

@bot.command(name="show_quete")
async def show_quete(ctx, quest_id: str = None):
    """
    Usage: !show_quete QE012   (ou QI019 / QR003)
    """
    if quest_id is None:
        await ctx.send("Usage : `!show_quete <ID>` (ex: `!show_quete QE012`)", allowed_mentions=NO_MENTIONS)
        return

    quest_id = quest_id.strip().upper()

    quete = charger_quete_par_id(quest_id)
    if not quete:
        await ctx.send(f"Je ne trouve pas la qu√™te `{quest_id}`.", allowed_mentions=NO_MENTIONS)
        return

    categorie = categorie_par_id(quest_id)

    # --- Construction d‚Äôembed (m√™me logique que tes DMs) ---
    if categorie == "Qu√™tes √ânigmes":
        embed = discord.Embed(
            title="üß© Qu√™te √ânigmes (APER√áU)",
            description=f"**{quete['id']} ‚Äì {quete['nom']}**",
            color=COULEURS_PAR_CATEGORIE.get(categorie, 0xCCCCCC)
        )
        img = quete.get("image_url")
        if img:
            embed.add_field(name="üí¨ R√©bus", value="Observe bien ce symbole...", inline=False)
            embed.set_image(url=img)
        else:
            embed.add_field(name="üí¨ √ânonc√©", value=quete["enonce"], inline=False)

        embed.add_field(name="üëâ Objectif", value="Tro uve la r√©ponse et r√©ponds-moi ici.", inline=False)
        embed.set_footer(text=f"üèÖ R√©compense : {quete['recompense']} Lumes")

    elif categorie == "Qu√™tes Recherches":
        embed = discord.Embed(
            title=f"üîé {categorie} (APER√áU)",
            description=f"**{quete['id']} ‚Äì {quete['nom']}**",
            color=COULEURS_PAR_CATEGORIE.get(categorie, 0xCCCCCC)
        )
        embed.add_field(name="üí¨ Indice", value=quete["description"], inline=False)
        embed.add_field(name="üëâ Objectif", value=quete["details_mp"], inline=False)
        embed.set_footer(text=f"üèÖ R√©compense : {quete['recompense']} Lumes")

    else:  # Interactions
        embed = discord.Embed(
            title=f"ü§ù {categorie} (APER√áU)",
            description=f"**{quete['id']} ‚Äì {quete['nom']}**",
            color=COULEURS_PAR_CATEGORIE.get(categorie, 0xCCCCCC)
        )
        embed.add_field(name="üí¨ Description", value=quete["description"], inline=False)
        embed.add_field(name="üëâ Objectif", value=quete["details_mp"], inline=False)
        embed.set_footer(text=f"üèÖ R√©compense : {quete['recompense']} Lumes")

    await ctx.send(embed=embed, allowed_mentions=NO_MENTIONS)


# ======================
#  EVENTS: COMPLETION
# ======================
@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    if payload.member is None or payload.member.bot:
        return

    user = payload.member
    user_id = str(payload.user_id)
    emoji = str(payload.emoji)

    quetes = charger_quetes()
    user_data = accepted_collection.find_one({"_id": user_id})
    if not user_data:
        return

    quetes_acceptees = user_data.get("quetes", [])
    toutes_quetes = [q for lst in quetes.values() for q in lst]

    for quete in toutes_quetes:
        if quete.get("type") != "reaction":
            continue
        if quete["id"] not in [q["id"] if isinstance(q, dict) else q for q in quetes_acceptees]:
            continue

        liste_emojis = quete.get("emoji", [])
        if isinstance(liste_emojis, str):
            liste_emojis = [liste_emojis]

        if emoji in liste_emojis:
            accepted_collection.update_one({"_id": user_id}, {"$pull": {"quetes": {"id": quete["id"]}}})
            completed_collection.update_one(
                {"_id": user_id},
                {"$addToSet": {"quetes": {"id": quete["id"], "nom": quete["nom"], "categorie": quete["categorie"]}},
                 "$set": {"pseudo": user.name}},
                upsert=True
            )
            utilisateurs.update_one(
                {"_id": user_id},
                {"$inc": {"lumes": quete["recompense"]},
                 "$setOnInsert": {"pseudo": user.name, "derniere_offrande": {}, "roles_temporaires": {}}},
                upsert=True
            )
            try:
                await user.send(f"‚ú® Tu as termin√© **{quete['nom']}** et gagn√© **{quete['recompense']} Lumes** !")
            except discord.Forbidden:
                ch = bot.get_channel(payload.channel_id)
                if ch:
                    await ch.send(f"‚úÖ {user.mention} a termin√© **{quete['nom']}** ! (MP non re√ßu)")
            return

@bot.event
async def on_message(message: discord.Message):
    if message.author.bot:
        return

    # R√©ponse aux √©nigmes en MP
    if isinstance(message.channel, discord.DMChannel):
        user = message.author
        user_id = str(user.id)
        contenu = message.content.strip()

        quetes = charger_quetes()
        user_data = accepted_collection.find_one({"_id": user_id})
        if not user_data:
            return

        quetes_acceptees = user_data.get("quetes", [])
        toutes_quetes = [q for lst in quetes.values() for q in lst]

        for quete in toutes_quetes:
            if quete["id"] not in [q["id"] if isinstance(q, dict) else q for q in quetes_acceptees]:
                continue

            bonne = normaliser(quete.get("reponse_attendue", ""))
            if normaliser(contenu) == bonne:
                accepted_collection.update_one({"_id": user_id}, {"$pull": {"quetes": {"id": quete["id"]}}})
                completed_collection.update_one(
                    {"_id": user_id},
                    {"$addToSet": {"quetes": {"id": quete["id"], "nom": quete["nom"], "categorie": quete["categorie"]}},
                     "$set": {"pseudo": user.name}},
                    upsert=True
                )
                utilisateurs.update_one(
                    {"_id": user_id},
                    {"$inc": {"lumes": quete["recompense"]},
                     "$setOnInsert": {"pseudo": user.name, "derniere_offrande": {}, "roles_temporaires": {}}},
                    upsert=True
                )
                await message.channel.send(
                    f"‚úÖ Parfait ! Tu as compl√©t√© **{quete['nom']}** et gagn√© **{quete['recompense']} Lumes** !"
                )
                return

    await bot.process_commands(message)

# ======================
#  SCHEDULER
# ======================
_scheduler = None

@bot.event
async def on_ready():
    global _scheduler
    print(f"‚úÖ Bot pr√™t : {bot.user}")

    if _scheduler is None:
        _scheduler = AsyncIOScheduler(timezone=TZ_PARIS)
        # Tous les jours 10:30 ‚Üí journali√®res
        _scheduler.add_job(lambda: bot.loop.create_task(poster_journalieres()),
                           CronTrigger(hour=10, minute=30))
        # Chaque lundi 10:31 ‚Üí hebdo (d√©cal√© d‚Äô1 min pour √©viter concurrence)
        _scheduler.add_job(lambda: bot.loop.create_task(poster_hebdo()),
                           CronTrigger(day_of_week='mon', hour=10, minute=31))
        # Annonce apr√®s chaque post hebdo
        if ANNOUNCE_CHANNEL_ID:
            _scheduler.add_job(lambda: bot.loop.create_task(annoncer_mise_a_jour()),
                               CronTrigger(day_of_week='mon', hour=10, minute=32))

        _scheduler.start()
        print("‚è∞ Scheduler d√©marr√© (journali√®res quotidiennes, hebdo le lundi).")

# ======================
#  RUN
# ======================
if __name__ == "__main__":
    if not DISCORD_TOKEN or not MONGO_URI or not QUESTS_CHANNEL_ID:
        print("‚ùå DISCORD_TOKEN / MONGO_URI / QUESTS_CHANNEL_ID manquant(s).")
    bot.run(DISCORD_TOKEN)
